---
title: "R Notebook"
output: html_notebook
---
# 各科變異數  
# 國	英	數甲	數乙	歷	地	公	物	化	生

```{r}
setwd('C:/Users/aduser01/Desktop/Special Topics/2 coef matrix/data')
df1 = read.csv("107 各科之分數分布.csv")

stud_cnt = c(47811,48365,23164,36077,26847,25642,22304,20038,21529,14307)  #student count of each subject
each_subj_var<- vector("double", length = 10)
#variance of each subject
cat("各科變異數\n")
for( x in 1:10){
    each_stud_grade <- vector("double", length = stud_cnt[x])
    chinese = df1[,x]
    grade = 100
    cnt = 1
    for(i in 1:101){
      for(j in 1:chinese[i]){
         if(chinese[i] == 0 )
              next;
         each_stud_grade[cnt] = grade
         cnt = cnt+1
      }
      if(grade==100) grade=grade-0.5
      else grade = grade-1
    }
    #print(head(each_stud_grade,20))
    #print(tail(each_stud_grade,20))
    print( var(each_stud_grade)*(stud_cnt[x]-1)/stud_cnt[x] )
    each_subj_var[x] = var(each_stud_grade)*(stud_cnt[x]-1)/stud_cnt[x]
    #write.table(each_stud_grade,file="C:/Users/aduser01/Desktop/553.csv",sep=",")
    rm(each_stud_grade)   #remove the vector
}


```


# 各組合變異數 

```{r}
setwd('C:/Users/aduser01/Desktop/Special Topics/2 coef matrix/data')
df2 = read.csv("107 各組合之分數分布.csv")
grade_array = df2[,2]
num_of_people_array = df2[,3]
x1 <- vector("double", length = 49000)   #temp, grade of each student
each_group_var<- vector("double", length = 60)  #variance of each group
cat("各組合\n人數       變異數","\n") 

for(i in 0:59){  #total 60 groups 0-59
  cnt=1
  a =1+i*100
  b=100+i*100
  for(j in a:b)
  {
      if(num_of_people_array[j] == 0 )
          next;
      for(xxx in 1:num_of_people_array[j]){
          x1[cnt] = grade_array[j]
          cnt = cnt+1
      }
  }
  #print(head(x1[1:cnt-1],20))
  #print(tail(x1[1:cnt-1],1000))
  if(i==5 ) write.table((x1[1:cnt-1]),file="C:/Users/aduser01/Desktop/553.csv",sep=",")
  n = cnt-1                                     #真正的總人數 of group1
  each_group_var[i+1] = var(x1[1:n])*(n-1)/n    #variance of group1
  cat(n," ",var(x1[1:n])*(n-1)/n,"\n")          #print各組合之人數&變異數
}
```

# 科目組合  
# 相關係數數矩陣

```{r}
setwd('C:/Users/aduser01/Desktop/Special Topics/2 coef matrix/data')
df3 = read.csv("107 各組合之採計科目.csv")

sigma_index = c("12","13","14","15","16","17","18","19","110","23","24","25","26","27","28","29","210","34","35","36","37","38","39","310","45","46","47","48","49","410","56","57","58","59","510","67","68","69","610","78","79","710","89","810","910")

get_sigma_index <- function(a,b)
{
   str=paste(as.character(a),as.character(b),sep="")
   x <- which(sigma_index == str)
   return (x)
} 

mtrx <- matrix(0,nrow=60,ncol=45)   # x:各組合所包含的變異數(權重=1) y:共60組合
colnames(mtrx) = sigma_index

visualize <- matrix(nrow = 10, ncol = 10) 
colnames(visualize) = c(" 國"," 英","數甲","數乙"," 歷"," 地"," 公"," 物"," 化"," 生")
rownames(visualize)=  c(" 國"," 英","數甲","數乙"," 歷"," 地"," 公"," 物"," 化"," 生")
for(i in 1:9)
  for(j in (i+1):10)
     visualize[i,j] = 0

var123plus <- vector("double", length = 60)   #sum of subjects' var in each group



for(i in 1:60){   #60
  for(j in 2:df3[i,1]){  #2
    for(k in (j+1):(df3[i,1]+1)){  #3,4
        mtrx[i, get_sigma_index(df3[i,j],df3[i,k]) ] = sqrt(each_subj_var[df3[i,j]]*each_subj_var[df3[i,k]])
        visualize[df3[i,j],df3[i,k]]=visualize[df3[i,j],df3[i,k]] + 1
    }
    var123plus[i] = var123plus[i] + each_subj_var[ df3[i,j] ]
  }
  var123plus[i]= var123plus[i] + each_subj_var[ df3[i,j+1] ]
}
#options(max.print=5000)
#mtrx
#visualize
#var123plus
```

#回歸
#each_group_var[60]  =  mtrx[60,45] %*% [45]  +  var123plus[60]
```{r}
y1 <- vector("double", length = 60) 
for(i in 1:60){
   y1[i] = each_group_var[i] - var123plus[i]
   y1[i]= y1[i]/2
   #print(y1[i])
}
mtrx <- data.frame(mtrx)
mtrx = mtrx[,which(colSums(abs(mtrx))!=0)]
#lmfit=lm(y1~.+0,data = mtrx)  
#summary(lmfit)
```

#ridge regression - 1
```{r}
library(glmnet)
x = model.matrix(y1~.,data = mtrx)[,-1]  

set.seed(1000)
cv_out = cv.glmnet(x,y1,alpha=0)         #cv_out$lambda.min
ridge_model = glmnet(x,y1,alpha=0) 
predict(ridge_model ,type="coefficient",s=cv_out$lambda.min)
```
#ridge - 1
```{r}
library(glmnet)
x = model.matrix(y1~.,data = mtrx)[,-1]  

#grid =seq(0.001,1000)
#ridge.mod = glmnet(x,y1,alpha=0,lambda=grid)    #alpha=0: ridge, alpha=1:lasso
#dim(coef(ridge.mod))                            #dimesion of the coefficients
    #for each lambda, it estimates 33 coefficients. one for intercept, 32for variables


#cross-validation: choose the best lambda
set.seed(1000)
cv_out = cv.glmnet(x,y1,alpha=0) 
plot(cv_out)  #show how cross validation error changes
#min(cv_out$cvm)  #15732.75
cat("min lambda: ", cv_out$lambda.min)  #71.1788733, where errors minimize

Model.Ridge = glmnet(x,y1,alpha=0) 
plot(Model.Ridge,xvar='lambda')
predict(Model.Ridge ,type="coefficient",s=6000) #cv_out$lambda.min
```


#ridge - 2
```{r}
library(ridge)
mod=linearRidge(formula=y1~.+0, data = mtrx)
summary(mod)
```
ridge - 3
```{r}
library(MASS)
ridge.sol <- lm.ridge(y1~.+0, data = mtrx, lambda = seq(0001,1000,length=200), model=TRUE)
print( ridge.sol$lambda[which.min(ridge.sol$GCV)] ) #1
print( ridge.sol$coef[which.min(ridge.sol$GCV)] )  #242.0323
#plot(ridge.sol )
ridge.sol <- lm.ridge(y1~.+0, data = mtrx, lambda = 2, model=TRUE)
summary(ridge.sol )
# 

```

